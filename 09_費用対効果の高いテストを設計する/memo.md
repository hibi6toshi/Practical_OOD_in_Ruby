# 費用対効果の高いテストを設計する

変更可能なコードを書くことは１つの技巧であり、その実践には３つのスキルが欠かせません。
１つ目はオブジェクト指向設計の理解です。
２つ目はコードのリファクタリングに長けていることです。
　「リファクタリングとは、**ソフトウェアの外部の振る舞いを保ったまま**で。内部の構造を改善していく作業を指します。
３つ目は価値の高いテストを書く能力

## 意図を持ったテスト（9.1）

**テストをすることの真の目的は、コストの削減です。**
テストにコストがかかることの解決方法は、テストを止めることではありません。上手くなることです。
テストか優れた価値を得るには、意図の明確さが求められます。

### テストの意図を知る

テストの実施には、潜在的な利益がいくつもあります。

■ バグを見つける
欠陥やバグを開発プロセスの初期段階で見つけることは、大きな利益となって返ってきます。
バグの発見と修正は、それがつくられた時間に近ければ近いほどより簡単です。

できること（できないこと）を初期段階で知ることは、将来利用可能な設計の選択肢を変えるために、いまの案ではない他の案を選択し直すきっかけとなることもあるでしょう。

■ 仕様書となる
テストは、唯一信頼できる設計の仕様書となります。
テストが伝える説明は、紙の文章が過去のものとなり、人間の記憶がなくなってずっとたったあとでも、真であり続けます。

■ 設計の決定を遅らせる
テストによって、設計の決定を遅らせることができます。
自身の設計スキルが磨かれるにつれ、ここの設計には「何か」が必要だけど、それが正確に何なのかを知るためにはまだ十分な情報がない、というような箇所が散見されるアプリケーションを描くようになります。それらは、追加の情報を待つべきであり箇所であり、具体的な設計にしなければならないという押し付けには勇気を持って抵抗すべきです。

**こういった状況が生じるのは、現時点ではただ 1 つの具体的なケースにのみ気づいているものの、複数の具象的なケースが近い将来新たに現れることを十分に予期している時のみです。それらのいくつもの具象的なケースを単一の中傷として扱うコードによって、いつか報われるときが来ることは知っているものの、現時点では、その抽象がどんなものになるのか予測するための十分な情報がない**のです。

テストがインターフェスに依存している場合、その根底にあるコードは、奔放にリファクタリングできます。テストは、そのインターフェースが正しく振る舞い続けることを証明するので、根底にあるコードを変更しても、テストの書き直しが求められることはありません。

■ 抽象を支える
良い設計は自然と抽象に依存する、独立した小さなオブジェクトの集まりになっていきます。
適切に設計されたアプリケーションの振る舞いは、徐々にそれらの抽象が相互に作用した結果となっていきます。
抽象的なコードは、素晴らしく柔軟性に富む設計のコンポーネントですが、それらがもたらす改善は、わずかにコストを伴います。個々の抽象は理解しやすいものの、全体の振る舞いを明らかにする箇所は、1 つとしてないのです。

設計の抽象度合によっては、どんな変更であっても、テストなしで安全に行うことがほぼ不可能になります。
テストは、あらゆる抽象のインターフェースを記録するものであり、従って、背後を守ってくれる壁のようなものです。

■ 設計の欠陥を明らかにする
対象のコードの、設計の欠陥を明らかにすることです。
テストのセットアップに苦痛が伴うのであれば、コードはコンテキストを要求しすぎています。1 つのオブジェクトをテストするために、他のオブジェクトをいくつも引き込まなければならないのであれば、そのコードは依存関係を持ちすぎています。テストを書くのが大変であれば、他のオブジェクトから見ても再利用が難しいでしょう。

しかし、その逆も必ずしも真ではありません。テストにコストがかかるからといって、必ずしもアプリケーションの設計がまずいわけではありません。
適切に設計されたコードに、出来の悪いテストを書くことは、技術上十分にあり得ます。従って、コストを下げるテストを実現するためには、対象のアプリケーションとテストの、両方を適切に設計する必要があります。

目標は、可能な限り低いコストでテストの恩恵を全て得ることです。
この目標を達成するための最適な方法は、問題となることのみをテストする、疎結合のテストをすることです。

■ 何をテストするのかを知る
ほとんどのプログラマーはテストを書きすぎています。多くの場合、これら不要のテストにかかるコストはとても高く、関わっているプログラマーがテストを s きらめてしまうほどです。
テストからより良い価値を得るための 1 つの単純な方法の 1 つは。より少ないテストを書くことです。最も安全にこれを実現するには、どのテストも一度だけ、それも適切な場所で行うようにしましょう。

テストをその本質へと抽出するには、何をテストしようとしているかについて、明確な考えを持っていなければなりません。それは、すでに知っている設計原則から導くことができます。

オブジェクト指向のアプリケーションを、ブラックボックスの集まりの間を飛び回る一連のメッセージだと考えてみましょう。どのオブジェクトもブラックボックスであるかのように扱うことで、他のオブジェクトが知ることを許される知識について制約が課されます。そして、公開される（パブリックな）知識についても、その境界を突き放すメッセージのみへと制限されます。

この、ほかのオブジェクトの内部を意図的に無視することが、設計の核心にあります。オブジェクトを、オブジェクトが応答するメッセージそのもの、かつそれだけであるかのように扱うことで、変更可能なアプリケーションを設計することができます。そして、この観点の重要性を理解して初めて、最低限のコストで最大限の利益を生むテストをかけるようになるのです。

結合は数を制限するだけでは十分ではありません。数をわずかにとどめたうえで、安定したものにすべきです。論理的に考えれば、パブリックインターフェースに定義されるメッセージを対象としたものを書くべきということがわかります。最もコストが高く最も利用性の低いテストは、不安定な内部の実装に結合することで、オブジェクトの格納壁に穴を開けます。それらの貪欲すぎるテストは、アプリケーション全体の正しさについても何も証明しないどころか、対象のクラスをリファクタリングするたびに毎回壊れるせいで、コストを高めてしまいます。

**テストは、オブジェクトの境界に入ってくる（受信する）か、出ていく（送信する）メッセージに集中すべきです。**受信メッセージは、それを受け取るメッセージのパブリックインターフェースを作ります。送信メッセージは、その定義上当然、他のオブジェクトに入っていきます。ですから、それは他のオブジェクトのインターフェースの一部です。

送信メッセージの状態をテストする必要がないからといいて、それらをテストしなくてよいという訳ではありません。
送信メッセージには 2 種類あ理、そのうちの 1 つは、別の種類のテストを必要とします。

送信メッセージには、副作用が全くないものもあります。そのため、そういったメッセージは送り手だけにとって問題となります。送り手は、もちろんその戻り値を気にします。しかし、アプリケーションの他のところでは、そのメッセージが送られたかなど気にしません。このような送信メッセージは、「クエリ（質問）」として知られていて、送り手のオブジェクトでテストされる必要はありません。

しかし、多くの送信メッセージは、アプリケーションが依存するものに対して副作用（ファイルの書き込みや、データベースへの記録の保存、オブザーバーによってアクションが起こされるなど）を持ちます。これらのメッセージは「コマンド（命令）」であり、それらが適切に送られたことを証明するのは送り手のオブジェクトの責任です。メッセージが送られたことの証明は、振る舞いのテストであり、状態のテストではありません。振る舞いのテストには、メッセージが送られた回数と、使われた引数についての表明が含まれます。

**何をテストするかのガイドラインは以下のようになります。**
受信メッセージは、その戻り値の状態がテストされるべきです。送信コマンドメッセージは、送られたことがテストされるべきです。送信クエリメッセージは、テストするべきではありません。
アプリケーションのオブジェクトが、互いに厳しくパブリックインターフェースのみを介して対処する限り、テストは上記のこと以外を把握する必要はありません。メッセージの最小限の集合に対してテストをするならば、どのオブジェクトのプライベートな振る舞いを変更してもテストに影響を与えることはないでしょう。送信コマンドメッセージをテストするとき、送られることのみを証明するためにテストを行うのであれば、結合が緩いテストになります。そしてその疎結合のテストは、アプリケーションの変更に対しても、テストが変更されることなく、耐えることができるでしょう。パブリックインターフェースが安定している限り、テストを一度書けば、書いた人はテストにより永遠に安心していられます。

### いつテストをするかを知る

テストを最初に書くと、オブジェクトに初めから多少の再利用性を持たせることになります。というよりも、そうでもしないとテストは全く書けないのです。そのため、初級の設計者はテストファーストでコードを書くことが最も有益です。
しかし、気をつけなければならないこともあります。テストを最初に書いても、適切に設計されたアプリケーションの代替にも保証にもなりません。

### テストの方法を知る

異なる様式のテスティングにも取り組まなければなりません。テスト駆動開発（TDD：Test Driven Devlelopment）と振る舞い駆動（BDD：Behavior Driven Development）があります。ここの決定は、それほど明快にできません。
TDD と BDD は対立するものであるように見えるかもしれませんが、連続体として見るのが最もよいでしょう。ここでは、自身の価値観と経験が自ずと自身の立ち位置を決めます。

どちらの様式も、テストファーストによってコードを書いていきます。
BDD は外から内へのアプローチをとり、アプリケーションの境界でオブジェクトを作り、内向きに入っていきます。まだ書かれていないオブジェクトを用意するために、モックが必要となります。
TDD は内から外へのアプローチをとります。通常、ドメインオブジェクトのテストから始まり、それたの新しく作られたドメインオブジェクトをコードの隣接するレイヤーのテストで再利用していきます。

テストをするときには、アプリケーションのオブジェクトを大きく 2 つのカテゴリに分けて考えることが役に立ちます。1 つ目のカテゴリーは、自身がテストするオブジェクトです。以降、これを「テスト対象オブジェクト」と呼びましょう。2 つ目のカテゴリーは、その他のもの全てです。
テストは、1 つ目のカテゴリーに従事するもの、つまい、テスト対象オブジェクトを知っている必要があります。しかし、2 つ目のカテゴリーのものについては、テストは可能な限り無知であるべきです。アプリケーションの他の部分はまるで見えないかのように装いましょう。テスト中に利用可能な情報は、テスト対象オブジェクトを見ることによってのみ得ることができるものであると考えるのです。
